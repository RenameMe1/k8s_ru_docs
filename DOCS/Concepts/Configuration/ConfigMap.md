---
tags:
  - k8s
---
# ConfigMaps

ConfigMap это API объект, который используется для хранения не конфиденциальных данных
в парах ключ-значение. [[Pod]]'ы могут использовать ConfigMap'ы как переменные
окружения, аргументы командной строки или как файлы конфигурации в [[volume]].

ConfigMap позволяет тебе отделить конфигурации специфичные для среды окружения
от вашего образа контейнера, так что ваше приложения можно легко переносить.

> [!WARNING]
> ##### Осторожно
ConfigMap не предоставляет секретность или шифрование. Если данные, которые
вы хотите хранить - конфиденциальные, то используйте Secret объект вместо ConfigMap
или используйте дополнительные (сторонние) инструменты для хранения ваших
приватных данных.

## Мотивация 

Используйте ConfigMap для настройки данных конфигурации в отдельности
от кода приложения.

Для примера, представьте, что вы разработали приложение которое вы можете
запустить на вашем собственном компьютере (для разработки) и в облаке 
(для обработки реального трафика). Вы пишите код смотрящий в переменную окружения
названную `DATABASE_HOST`. Локально, вы устанавливаете переменную localhost. 
В облаке вы устанавливаете ссылку на Kubernetes Service который предоставляет
компоненты базы данных вашему кластеру. Это позволяет работать твоему container imagine
в облаке и debug в точно таком же коде локально, если это необходимо.

> [!NOTE]
> ##### Заметка 
ConfigMap не разработан для хранения длинных chunk'ов данных. Данные 
хранящиеся в ConfigMap не могут превосходить 1MiB. Если вам необходимо
хранить настройки которые больше чем этот лимит, вы можете захотеть 
рассмотреть монтирование тома или использование отдельной базы данных или
файлового сервиса.

## Объект ConfigMap

ConfigMap это API объект, которые позволяет тебе хранить конфигурацию
использования ее другими объектами. В отличии от большинства Kubernetes
объектов находящихся в `spec`, ConfigMap имеет поля `data` и `binaryData`.
Эти поля принимают пары ключ-значение. Оба поля `data` и`binaryData`
не обязательны. Поле `data` разработана для содержания UTF-8 строк, в то 
время как `binaryData` разработано для содержания двоичных данных таких как
шифрованные base64 строки.

Имя ConfigMap должно быть действительным [[DNS subdomain name]].

Каждый ключ под полем `data` или `binaryData` должен состоять из символов 
буквенно-цифровых, "-", "_" или ".". Ключи хранящиеся в `data` не должны пересекаться с ключами из `binaryData`.

Начиная с версии 1.19 вы можете добавить `immutable(неизменяемое)`
поле в ConfigMap, что бы создать [[Immutable ConfigMap]].

## ConfigMap и [[Pod]]'ы .

Вы можете написать [[Pod]] `spec` ссылающийся на ConfigMap, настраивающий
контейнер(ы) в этом [[Pod]] основываясь на данных из ConfigMap. [[Pod]] и ConfigMap
должны быть в том же namespace.

>[!NOTE]
> ##### Заметка
`spec` для [[static Pod]] не может ссылаться на ConfigMap или любой другой
API объект.

 Здесь пример ConfigMap который имеет некоторые ключи с одиночными значениями
 и остальные ключи, где значения выглядят как фрагменты формата конфигурации.


``` yaml
apiVersion: v1
kind: ConfigMap
metadata:
	name: game-demo
data:
  # Ключи как свойство; каждый ключ преобразуется в простое значение
  player_initial_lives: "3"
  ui_properties_file_name: "user-interface.properties
  # Ключи как файл
  game.properties: |
    enemy.types=aliens,monsters
    player.maximum-lives=5    
  user-interface.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=true
```

Есть четыре разных пути ConfigMap, которые вы можете использовать 
для настройки контейнера внутри [[Pod]]:

- Внутренними командами и аргументами контейнера
- Переменными окружения для контейнера
- Добавление файла в read-only том, для чтения приложением
-  Написать код, запускающийся внутри [[Pod]], который использует Kubernetes API
для чтения ConfigMap

Эти разные методы предлагают себя для разных путей моделирования потребления
данных. Для первых трех методов [[!Kubelet]] использует данные из ConfigMap при запуске
контейнера в [[Pod]]. 

Четвертый метод означает, что у вас есть написанный код для чтения ConfigMap
и его данных. Однако, потому-что вы используете Kubernetes API напрямую,
ваше приложение может подписаться на получение обновлений ConfigMap внесенных
в любое время и реагировать когда это обновление случится. Получив доступ
к Kubernetes API точечно, это так же даст вам доступ к ConfigMap разных 
namespace.

Здесь пример [[Pod]] использующего значения из `game-demo` для настройки [[Pod]].

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: configmap-demo-pod
spec:
  containers:
    - name: demo
      image: alpine
      command: ["sleep", "3600"]
      env:
        # Определим переменные окружения
        - name: PLAYER_INITIAL_LIVES # Обратите внимание, что регистр здесь другой в отличии от ключей в ConfigMap.
          valueFrom:
            configMapKeyRef:
              name: game-demo           # Имя ConfigMap.
              key: player_initial_lives # Ключ для получения значения.
        - name: UI_PROPERTIES_FILE_NAME
          valueFrom:
            configMapKeyRef:
              name: game-demo
              key: ui_properties_file_name
      volumeMounts:
      - name: config
        mountPath: "/config"
        readOnly: true
  volumes:
  # Вы настраивате тома в уровне Pod'а, затем монтируете их в контейнер внутри Pod'а
  - name: config
    configMap:
      # Укажите имя ConfigMap которе вы хотите смонтировать.
      name: game-demo
      # Список ключей из ConfigMap созданных как файл
      items:
      - key: "game.properties"
        path: "game.properties"
      - key: "user-interface.properties"
        path: "user-interface.properties"
```

ConfigMap не делает различий между однострочными значениями свойств и многострочными файловыми значениями. Какое дело как [[Pod]]'ы и другие объекты потребляют эти объекты.

Например, определим том и монтируем его внутрь `demo` контейнера как `/config` создав два файла, `/config/game.properties` и `/config/user-interface.properies`, несмотря на то, что ConfigMap имеет 4 ключа. Это потому-что [[Pod]]
определяет указанный массив `items` в секцию `volumes`. Если вы пренебрежете списком `items`, каждый ключ в ConfigMap станет файлом с таким же именем как и ключ, и вы получите четыре файла.

## Использование ConfigMap'ов

ConfigMap'ы могут быть монтированы как тома данных. ConfigMap'ы могут так же быть использованы другими частями системы, без прямого контакта с [[Pod]]. Для примера, ConfigMap'ы могут хранить данные, которые другие части системы должны использовать для конфигурации. 

Самый распространенный способ использования ConfigMap'ов - конфигурация настроек для контейнеров работающих в [[Pod]] в том же [[namespase]]. Вы можете так же использовать ConfigMap отдельно.

Например, вы можете столкнуться с addons или operators, которые регулируют свое поведение основываясь на ConfigMap.

### Использование ConfigMap'ов как файлы для [[Pod]]

Для использования ConfigMap в томе [[Pod]]'а:
	1) Создайте ConfigMap или используйте один из существующих. Множество [[Pod]] могут ссылаться на тот же ConfigMap.
	2) Модифицируйте ваше определение [[Pod]] добавив том в `.spec.volumes[].`. Назовите том как хотите, и настройте поле `.spec.volumes[].configMap.name` ссылающимся на ваш ConfigMap объект.
	3) Добавьте `.spec.containers[].volumeMounts[]` каждому контейнеру, которому нужен ConfigMap. 
	4) Модифицируйте ваш image или команду так, что ваша программа искала файлы в этой директории. Каждый ключ в `data` ConfigMap'a становится именем файла в `mountPath`. 

Это пример [[Pod]] который монтирует ConfigMap в том:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    configMap:
      name: myconfigmap
```

Каждый ConfigMap который вы хотите использовать необходимо обозначить в `.spec.volumes`.

Если есть несколько контейнеров в [[Pod]], то каждый контейнер нуждается в своем собственно блоке `volumeMounts`, но только один `.spec.volumes` нужен каждому ConfigMap.

#### Монтирование CongifMap'ов и автоматическое обновление 

Когда ConfigMap используемая в данный момент в томе обновляется, выданные ключи в итоге обновляются также. [[!Kubelet]] независимо проверяет монтированные ConfigMap'ы на "свежесть" на каждый периодической синхронизации. Однако, [[!Kubelet]] используется локальный кэш для получения текущих значений ConfigMap'ов. Тип кэширования настраивается использованием поля `configMapAndSecretChangeDetectionStrategy` в структуре [[KubeletConfiguration]]. ConfigMap может распространяться путем наблюдения (по умолчанию), на основе ttl или перенаправления всех запросов прямо в API сервер. Как результат, общая задержка в момент когда ConfigMap обновляется до момента когда новые ключи выдаются [[Pod]]'у может быть таким долгим, как период синхронизации [[!Kubelet]] + задержка распространения кэша, где задержка распространения кэша зависит от выбранного типа кэширования (Это эквивалентно наблюдению задержки распространения, кэша ttl или нулю соответственно).

ConfigMap принимается как переменные окружения не обновляющиеся автоматически и необходимостью перезапуска [[Pod]]'а

> [!NOTE]
> ##### Заметка 
Контейнер использующий ConfigMap как монтированный том [subPath], не будет получать обновления ConfigMap

### Использование ConfigMap'ов как переменные окружения

Для использования ConfigMap в переменной окружения [[Pod]]'a:
1) Для каждого контейнера в вашей спецификации [[Pod]]'а, добавьте переменную окружения для каждого ConfigMap ключа, который вы хотите использовать в поле `env[].valueFrom.configMapKeyRef`
2) Модифицируйте ваш образ и/или команду терминала так, что программа будет искать значения в указанных переменных окружения
Это пример определения ConfigMap как переменной окружения [[Pod]]'а: 

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: env-configmap
spec:
  containers:
  - name: envars-test-container
    image: nginx
    env:
    - name: CONFIGMAP_USERNAME
      valueFrom:
        configMapKeyRef:
          name: myconfigmap
          key: username
```

Это важно отметить, что длина символов допускаемых для имен переменной окружения в [[Pod]]'aх [ограничено](!Define%20Environment%20Variables%20for%20a%20Container.md). Если любой ключ не соответствует правилам, эти ключи становятся не доступным для твоего контейнера, даже если [[Pod]]'у разрешен запуск.
## Immutable CongifMap'ы

**Особенность добавлена**: Kubernetes v1.21 \[stable\]

Особенность Kubernetes *Immutable Secrets and ConfigMaps* обеспечивает опцию установить отдельный [[Secrets]] и ConfigMap как неизменяемый. Для кластеров экстенсивно использующих ConfigMap (не менее десятка сотен уникальных ConfigMap'ов монтированных в Pod) препятствуют изменению их данных, имеет следующие особенности:
- Защищает тебя от случайных (или нежелательных) обновлений, которые могут стать причиной перебоев в работе.
- Улучшают производительность твоего кластера значительным уменьшением нагрузки на `kube-apiserver`, закрывая просмотр ConfigMap'ов.

Вы можете создать неизменяемый ConfigMap установив  после `imutabel` в значение `true`. Например:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  ...
data:
  ...
immutable: true
```

Как только ConfigMap помечен как неизменяемый, *не* возможно ни отменить это изменение не изменить контент в поле `data` или `binaryData`. Вы можете только удалить и пересоздать ConfigMap. Потому что существующие [[Pod]] поддерживают точку монтирования удаленного ConfigMap'а, его рекомендовано пересоздать этим [[Pod]].

## Что дальше?
- Ознакомьтесь с [[Secrets]]
- Ознакомьтесь с [[Configure a Pod to Use a ConfigMap]]
- Ознакомьтесь с [[changing a ConfigMap (or any other Kubernetis object)]]
- Ознакомьтесь с [[The Twelve-Factor App]] для понимания мотивации разделения кода от конфигураций